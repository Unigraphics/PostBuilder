# -*- mode: TCL; fill-column: 75; tab-width: 8; coding: iso-latin-1-unix -*-
#
#	$Id: Event.tcl,v 1.6 2004/04/09 21:37:01 hobbs Exp $
#
# Event.tcl --
#
#	Handles the event bindings of the -command and -browsecmd options
#	(and various of others such as -validatecmd).
#
# Copyright (c) 1993-1999 Ioi Kim Lam.
# Copyright (c) 2000-2001 Tix Project Group.
# Copyright (c) 2004 ActiveState
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#==========
# PB v12.0
#==========
# May-18-2017 gsl - Added tk_bgerror & tk_dialog needed for tixBuiltInCmdErrorHandler
#                   => Just comment out the call to bgerror will suppress the error w/o telling anything to user! NG.

#----------------------------------------------------------------------
# Evaluate high-level bindings (-command, -browsecmd, etc):
# with % subsitution or without (compatibility mode)
#
#
# BUG : if a -command is intercepted by a hook, the hook must use
#       the same record name as the issuer of the -command. For the time
#	being, you must use the name "bind" as the record name!!!!!
#
#----------------------------------------------------------------------

namespace eval ::tix {
    variable event_flags ""
    set evs [list % \# a b c d f h k m o p s t w x y A B E K N R S T W X Y]
    foreach ev $evs {
	lappend event_flags "%$ev"
    }

    # This is a "name stack" for storing the "bind" structures
    #
    # The bottom of the event stack is usually a raw event (generated by
    # tixBind) but it may also be a programatically triggered (caused by
    # tixEvalCmdBinding)
    variable EVENT
    set EVENT(nameStack)	""
    set EVENT(stackLevel)	0
}

proc tixBind {tag event action} {
    set cmd [linsert $::tix::event_flags 0 _tixRecordFlags $event]
    append cmd "; $action; _tixDeleteFlags;"

    bind $tag $event $cmd
}

proc tixPushEventStack {} {
    variable ::tix::EVENT

    set lastEvent [lindex $EVENT(nameStack) 0]
    incr EVENT(stackLevel)
    set thisEvent ::tix::_event$EVENT(stackLevel)

    set EVENT(nameStack) [list $thisEvent $EVENT(nameStack)]

    if {$lastEvent == ""} {
	upvar #0 $thisEvent this
	set this(type) <Application>
    } else {
	upvar #0 $lastEvent last
	upvar #0 $thisEvent this

	foreach name [array names last] {
	    set this($name) $last($name)
	}
    }

    return $thisEvent
}

proc tixPopEventStack {varName} {
    variable ::tix::EVENT

    if {$varName ne [lindex $EVENT(nameStack) 0]} {
	error "unmatched tixPushEventStack and tixPopEventStack calls"
    }
    incr EVENT(stackLevel) -1
    set EVENT(nameStack) [lindex $EVENT(nameStack) 1]
    global $varName
    unset $varName
}


# Events triggered by tixBind
#
proc _tixRecordFlags [concat event $::tix::event_flags] {
    set thisName [tixPushEventStack]; upvar #0 $thisName this

    set this(type) $event
    foreach f $::tix::event_flags {
	set this($f) [set $f]
    }
}

proc _tixDeleteFlags {} {
    variable ::tix::EVENT

    tixPopEventStack [lindex $EVENT(nameStack) 0]
}

# programatically trigged events
#
proc tixEvalCmdBinding {w cmd {subst ""} args} {
    global tixPriv tix
    variable ::tix::EVENT

    set thisName [tixPushEventStack]; upvar #0 $thisName this

    if {$subst != ""} {
	upvar $subst bind

	if {[info exists bind(specs)]} {
	    foreach spec $bind(specs) {
		set this($spec) $bind($spec)
	    }
	}
	if {[info exists bind(type)]} {
	    set this(type) $bind(type)
	}
    }

    if {[catch {
	if {![info exists tix(-extracmdargs)]
	    || [string is true -strict $tix(-extracmdargs)]} {
	    # Compatibility mode
	    set ret [uplevel \#0 $cmd $args]
	} else {
	    set ret [uplevel 1 $cmd]
	}
    } error]} {
	if {[catch {tixCmdErrorHandler $error} error]} {
	    # double fault: just print out 
	    tixBuiltInCmdErrorHandler $error
	}
	tixPopEventStack $thisName
	return ""
    } else {
	tixPopEventStack $thisName

	return $ret
    }
}

proc tixEvent {option args} {
    global tixPriv
    variable ::tix::EVENT
    set varName [lindex $EVENT(nameStack) 0]

    if {$varName == ""} {
	error "tixEvent called when no event is being processed"
    } else {
	upvar #0 $varName event
    }

    switch -exact -- $option {
	type {
	    return $event(type)
	}
	value {
	    if {[info exists event(%V)]} {
		return $event(%V)
	    } else {
		return ""
	    }
	}
	flag {
	    set f %[lindex $args 0]
	    if {[info exists event($f)]} {
		return $event($f)
	    }
	    error "The flag \"[lindex $args 0]\" does not exist"
	}
	match {
	    return [string match [lindex $args 0] $event(type)]
	}
	default {
	    error "unknown option \"$option\""
	}
    }
}

#<May-18-2017 gsl> This command has been removed from Tk8.4. Clone it from Tk8.0
# bgerror.tcl --
#
# This file contains a default version of the bgerror procedure.  It
# posts a dialog box with the error message and gives the user a chance
# to see a more detailed stack trace.
#
# SCCS: @(#) bgerror.tcl 1.16 97/08/06 09:19:50
#
# Copyright (c) 1992-1994 The Regents of the University of California.
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.


# bgerror --
# This is the default version of bgerror. 
# It tries to execute tkerror, if that fails it posts a dialog box containing
# the error message and gives the user a chance to ask to see a stack
# trace.
# Arguments:
# err -        The error message.

#<May-18-2017 gsl> Renamed "bgerror" to "tk_bgerror".
proc tk_bgerror err {
    global errorInfo tcl_platform

    # save errorInfo which would be erased in the catch below otherwise.
    set info $errorInfo ;

    # For backward compatibility :
    # Let's try to execute "tkerror" (using catch {tkerror ...} 
    # instead of searching it with info procs so the application gets
    # a chance to auto load it using its favorite "unknown" mecanism.
    # (we do the default dialog only if we get a TCL_ERROR (=1) return
    #  code from the tkerror trial, other ret codes are passed back
    #  to our caller (tcl background error handler) so the called "tkerror"
    #  can still use  return -code break, to skip remaining messages
    #  in the error queue for instance)  -- dl
    set ret [catch {tkerror $err} msg];
    if {$ret != 1} {return -code $ret $msg}

    # Ok the application's tkerror either failed or was not found
    # we use the default dialog then :
    if {$tcl_platform(platform) == "macintosh"} {
   set ok Ok
    } else {
   set ok OK
    }
   #<May-18-2017 gsl> ::tk_dialog was tk_dialog.
    set button [tk_dialog .bgerrorDialog "Error in Tcl Script" \
       "Error: $err" error 0 $ok "Skip Messages" "Stack Trace"]
    if {$button == 0} {
   return
    } elseif {$button == 1} {
   return -code break
    }

    set w .bgerrorTrace
    catch {destroy $w}
    toplevel $w -class ErrorTrace
    wm minsize $w 1 1
    wm title $w "Stack Trace for Error"
    wm iconname $w "Stack Trace"
    button $w.ok -text OK -command "destroy $w" -default active
    if {$tcl_platform(platform) == "macintosh"} {
      text $w.text -relief flat -bd 2 -highlightthickness 0 -setgrid true \
       -yscrollcommand "$w.scroll set" -width 60 -height 20
    } else {
      text $w.text -relief sunken -bd 2 -yscrollcommand "$w.scroll set" \
       -setgrid true -width 60 -height 20
    }
    scrollbar $w.scroll -relief sunken -command "$w.text yview"
    pack $w.ok -side bottom -padx 3m -pady 2m
    pack $w.scroll -side right -fill y
    pack $w.text -side left -expand yes -fill both
    $w.text insert 0.0 $info
    $w.text mark set insert 0.0

    bind $w <Return> "destroy $w"
    bind $w.text <Return> "destroy $w; break"

    # Center the window on the screen.

    wm withdraw $w
    update idletasks
    set x [expr [winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 \
       - [winfo vrootx [winfo parent $w]]]
    set y [expr [winfo screenheight $w]/2 - [winfo reqheight $w]/2 \
       - [winfo vrooty [winfo parent $w]]]
    wm geom $w +$x+$y
    wm deiconify $w

    # Be sure to release any grabs that might be present on the
    # screen, since they could make it impossible for the user
    # to interact with the stack trace.

    if {[grab current .] != ""} {
   grab release [grab current .]
    }
}

#<May-18-2017 gsl> Grab from Tk8.4 library. tk_dialog is needed in "bgerror" command above.
# dialog.tcl --
#
# This file defines the procedure tk_dialog, which creates a dialog
# box containing a bitmap, a message, and one or more buttons.
#
# RCS: @(#) $Id: dialog.tcl,v 1.14.2.1 2003/10/22 15:22:07 dkf Exp $
#
# Copyright (c) 1992-1993 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#
# ::tk_dialog:
#
# This procedure displays a dialog box, waits for a button in the dialog
# to be invoked, then returns the index of the selected button.  If the
# dialog somehow gets destroyed, -1 is returned.
#
# Arguments:
# w -    Window to use for dialog top-level.
# title -   Title to display in dialog's decorative frame.
# text - Message to display in dialog.
# bitmap -  Bitmap to display in dialog (empty string means none).
# default - Index of button that is to display the default ring
#     (-1 means none).
# args - One or more strings to display in buttons across the
#     bottom of the dialog box.

proc ::tk_dialog {w title text bitmap default args} {
    global tcl_platform
    variable ::tk::Priv

    # Check that $default was properly given
    if {[string is int $default]} {
   if {$default >= [llength $args]} {
       return -code error "default button index greater than number of\
          buttons specified for tk_dialog"
   }
    } elseif {[string equal {} $default]} {
   set default -1
    } else {
   set default [lsearch -exact $args $default]
    }

    # 1. Create the top-level window and divide it into top
    # and bottom parts.

    catch {destroy $w}
    toplevel $w -class Dialog
    wm title $w $title
    wm iconname $w Dialog
    wm protocol $w WM_DELETE_WINDOW { }

    # Dialog boxes should be transient with respect to their parent,
    # so that they will always stay on top of their parent window.  However,
    # some window managers will create the window as withdrawn if the parent
    # window is withdrawn or iconified.  Combined with the grab we put on the
    # window, this can hang the entire application.  Therefore we only make
    # the dialog transient if the parent is viewable.
    #
    if {[winfo viewable [winfo toplevel [winfo parent $w]]] } {
   wm transient $w [winfo toplevel [winfo parent $w]]
    }    

    if {[string equal $tcl_platform(platform) "macintosh"]
       || [string equal [tk windowingsystem] "aqua"]} {
   ::tk::unsupported::MacWindowStyle style $w dBoxProc
    }

    frame $w.bot
    frame $w.top
    if {[string equal [tk windowingsystem] "x11"]} {
   $w.bot configure -relief raised -bd 1
   $w.top configure -relief raised -bd 1
    }
    pack $w.bot -side bottom -fill both
    pack $w.top -side top -fill both -expand 1

    # 2. Fill the top part with bitmap and message (use the option
    # database for -wraplength and -font so that they can be
    # overridden by the caller).

    option add *Dialog.msg.wrapLength 3i widgetDefault
    if {[string equal $tcl_platform(platform) "macintosh"]
       || [string equal [tk windowingsystem] "aqua"]} {
   option add *Dialog.msg.font system widgetDefault
    } else {
   option add *Dialog.msg.font {Times 12} widgetDefault
    }

    label $w.msg -justify left -text $text
    pack $w.msg -in $w.top -side right -expand 1 -fill both -padx 3m -pady 3m
    if {[string compare $bitmap ""]} {
   if {([string equal $tcl_platform(platform) "macintosh"]
        || [string equal [tk windowingsystem] "aqua"]) &&\
      [string equal $bitmap "error"]} {
       set bitmap "stop"
   }
   label $w.bitmap -bitmap $bitmap
   pack $w.bitmap -in $w.top -side left -padx 3m -pady 3m
    }

    # 3. Create a row of buttons at the bottom of the dialog.

    set i 0
    foreach but $args {
   button $w.button$i -text $but -command [list set ::tk::Priv(button) $i]
   if {$i == $default} {
       $w.button$i configure -default active
   } else {
       $w.button$i configure -default normal
   }
   grid $w.button$i -in $w.bot -column $i -row 0 -sticky ew \
      -padx 10 -pady 4
   grid columnconfigure $w.bot $i
   # We boost the size of some Mac buttons for l&f
   if {[string equal $tcl_platform(platform) "macintosh"]
       || [string equal [tk windowingsystem] "aqua"]} {
       set tmp [string tolower $but]
       if {[string equal $tmp "ok"] || [string equal $tmp "cancel"]} {
      grid columnconfigure $w.bot $i -minsize [expr {59 + 20}]
       }
   }
   incr i
    }

    # 4. Create a binding for <Return> on the dialog if there is a
    # default button.

    if {$default >= 0} {
   bind $w <Return> "
   [list $w.button$default] configure -state active -relief sunken
   update idletasks
   after 100
   set ::tk::Priv(button) $default
   "
    }

    # 5. Create a <Destroy> binding for the window that sets the
    # button variable to -1;  this is needed in case something happens
    # that destroys the window, such as its parent window being destroyed.

    bind $w <Destroy> {set ::tk::Priv(button) -1}

    # 6. Withdraw the window, then update all the geometry information
    # so we know how big it wants to be, then center the window in the
    # display and de-iconify it.

    wm withdraw $w
    update idletasks
    set x [expr {[winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 \
       - [winfo vrootx [winfo parent $w]]}]
    set y [expr {[winfo screenheight $w]/2 - [winfo reqheight $w]/2 \
       - [winfo vrooty [winfo parent $w]]}]
    # Make sure that the window is on the screen and set the maximum
    # size of the window is the size of the screen.  That'll let things
    # fail fairly gracefully when very large messages are used. [Bug 827535]
    if {$x < 0} {
   set x 0
    }
    if {$y < 0} {
   set y 0
    }
    wm maxsize $w [winfo screenwidth $w] [winfo screenheight $w]
    wm geom $w +$x+$y
    wm deiconify $w

    # 7. Set a grab and claim the focus too.

    set oldFocus [focus]
    set oldGrab [grab current $w]
    if {[string compare $oldGrab ""]} {
   set grabStatus [grab status $oldGrab]
    }
    grab $w
    if {$default >= 0} {
   focus $w.button$default
    } else {
   focus $w
    }

    # 8. Wait for the user to respond, then restore the focus and
    # return the index of the selected button.  Restore the focus
    # before deleting the window, since otherwise the window manager
    # may take the focus away so we can't redirect it.  Finally,
    # restore any grab that was in effect.

    vwait ::tk::Priv(button)
    catch {focus $oldFocus}
    catch {
   # It's possible that the window has already been destroyed,
   # hence this "catch".  Delete the Destroy handler so that
   # Priv(button) doesn't get reset by it.

   bind $w <Destroy> {}
   destroy $w
    }
    if {[string compare $oldGrab ""]} {
      if {[string compare $grabStatus "global"]} {
       grab $oldGrab
      } else {
          grab -global $oldGrab
   }
    }
    return $Priv(button)
}

# tixBuiltInCmdErrorHandler --
#
#	Default method to report command handler errors. This procedure is
#	also called if double-fault happens (command handler causes error,
#	then tixCmdErrorHandler causes error).
#
proc tixBuiltInCmdErrorHandler {errorMsg} {
    global errorInfo tcl_platform
    if {![info exists errorInfo]} {
	set errorInfo "???"
    }
   #<May-18-2017 gsl> Renamed bgerror to tk_bgerror
    if { $tcl_platform(platform) eq "windows"} {
	tk_bgerror "Tix Error: $errorMsg"
    } else {
	puts "Error:\n $errorMsg\n$errorInfo"
    }
}

# tixCmdErrorHandler --
#
#	You can redefine this command to handle the errors that occur
#	in the command handlers. See the programmer's documentation
#	for details
#
if {![llength [info commands tixCmdErrorHandler]]} {
    proc tixCmdErrorHandler {errorMsg} {
	tixBuiltInCmdErrorHandler $errorMsg
    }
}

